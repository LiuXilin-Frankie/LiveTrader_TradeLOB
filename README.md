# LiveTrader_TradeLOB
基于 trade, LOB 数据的 Event-driven Backtest System

## 详情：
策略交易回测 - Event Driven Backtest System:
+ 同时可以获得两个资产的行情信息
+ 基于高频的 trade, tick, depth 数据，不基于kline数据
+ 根据后续行情模拟撮合


# System FrameWork
Idea from [quantstart article](https://www.quantstart.com/articles/Event-Driven-Backtesting-with-Python-Part-I/)


To apply an event-driven approach to a backtesting system it is necessary to define our components (or objects) that will handle specific tasks:

+ Event - The Event is the fundamental class unit of the event-driven system. It contains a type (such as "MARKET", "SIGNAL", "ORDER" or "FILL") that determines how it will be handled within the event-loop.

+ Event Queue - The Event Queue is an in-memory Python Queue object that stores all of the Event sub-class objects that are generated by the rest of the software.

+ DataHandler - The DataHandler is an abstract base class (ABC) that presents an interface for handling both historical or live market data. This provides significant flexibility as the Strategy and Portfolio modules can thus be reused between both approaches. The DataHandler generates a new MarketEvent upon every heartbeat of the system (see below).

+ Strategy - The Strategy is also an ABC that presents an interface for taking market data and generating corresponding SignalEvents, which are ultimately utilised by the Portfolio object. A SignalEvent contains a ticker symbol, a direction (LONG or SHORT) and a timestamp.

+ Portfolio - This is an ABC which handles the order management associated with current and subsequent positions for a strategy. It also carries out risk management across the portfolio, including sector exposure and position sizing. In a more sophisticated implementation this could be delegated to a RiskManagement class. The Portfolio takes SignalEvents from the Queue and generates OrderEvents that get added to the Queue.

+ ExecutionHandler - The ExecutionHandler simulates a connection to a brokerage. The job of the handler is to take OrderEvents from the Queue and execute them, either via a simulated approach or an actual connection to a liver brokerage. Once orders are executed the handler creates FillEvents, which describe what was actually transacted, including fees, commission and slippage (if modelled).

+ The Loop - All of these components are wrapped in an event-loop that correctly handles all Event types, routing them to the appropriate component.






