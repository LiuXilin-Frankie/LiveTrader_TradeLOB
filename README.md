# LiveTrader_TradeLOB
基于 trade, LOB 数据的 Event-driven Backtest System

## 详情：
策略交易回测 - Event Driven Backtest System:
+ 同时可以获得两个资产的行情信息
+ 基于高频的 trade, tick, depth 数据，不基于kline数据
+ 根据后续行情模拟撮合


# System FrameWork
Idea from [quantstart article](https://www.quantstart.com/articles/Event-Driven-Backtesting-with-Python-Part-I/), 以下是该网站对于这一类回测系统基本架构的描述。如果您想了解本回测框架相比于该网站的区别，请看下文‘特性’。


To apply an event-driven approach to a backtesting system it is necessary to define our components (or objects) that will handle specific tasks:

+ Event - The Event is the fundamental class unit of the event-driven system. It contains a type (such as "MARKET", "SIGNAL", "ORDER" or "FILL") that determines how it will be handled within the event-loop.

+ Event Queue - The Event Queue is an in-memory Python Queue object that stores all of the Event sub-class objects that are generated by the rest of the software.

+ DataHandler - The DataHandler is an abstract base class (ABC) that presents an interface for handling both historical or live market data. This provides significant flexibility as the Strategy and Portfolio modules can thus be reused between both approaches. The DataHandler generates a new MarketEvent upon every heartbeat of the system (see below).

+ Strategy - The Strategy is also an ABC that presents an interface for taking market data and generating corresponding SignalEvents, which are ultimately utilised by the Portfolio object. A SignalEvent contains a ticker symbol, a direction (LONG or SHORT) and a timestamp.

+ Portfolio - This is an ABC which handles the order management associated with current and subsequent positions for a strategy. It also carries out risk management across the portfolio, including sector exposure and position sizing. In a more sophisticated implementation this could be delegated to a RiskManagement class. The Portfolio takes SignalEvents from the Queue and generates OrderEvents that get added to the Queue.

+ ExecutionHandler - The ExecutionHandler simulates a connection to a brokerage. The job of the handler is to take OrderEvents from the Queue and execute them, either via a simulated approach or an actual connection to a liver brokerage. Once orders are executed the handler creates FillEvents, which describe what was actually transacted, including fees, commission and slippage (if modelled).

+ The Loop - All of these components are wrapped in an event-loop that correctly handles all Event types, routing them to the appropriate component.


### 特性：
1. 为了满足跨交易所交易的策略需求，品类命名被写为 "symbol_exchange" 的形式，比如说 "btc_usdt_binance", 所有需要考虑的品类名被存储在 symbol_exchange_list 中
2. 推送的顺序规则为: 1.品类名按照字母大小顺序排序, 2. trade 优先于 tick(LOB) 
3. 同一个时间点 timestamp 可能有多种数据，可能有多次 trade 信息。
4. 区别于原网站 1.使用迭代器推送整个数据，2.对时间异步的情况使用插值fillna的方法。本回测框架作出改进：1.将回测进行到的时间戳作为迭代器并且可以由外部访问；2.如果该时间下该币对没有数据，则不推送；3.约束了推送的数据格式，每一条交易是一个单独的object，同一时间的所有交易信息由list推送过来
5. Portfolio 不再掌管策略的下单，而是仅保留记录净值，仓位，成本等信息的功能。这也就代表了，portfolio模块可以相对固定，仅需要修改Strategy就可以使得代码运行起来。同时删除了 Signal 这个信息



